/*
924. Minimize Malware Spread
*/


// BFS TC:O(n^2) SC:O(n^2)
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
       
        unordered_set<int> set(initial.begin(), initial.end());
        vector<vector<int>> next(n);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i == j) continue;
                if(graph[i][j] == 1) {
                    next[i].push_back(j);
                    next[j].push_back(i);
                }
            }
        }

        vector<int> have(n, 1);
        unordered_set<int> deleted;
        for(auto x : initial){
            if(deleted.find(x) != deleted.end()) continue;
            queue<int> q;
            q.push(x);
            vector<bool> visited(n);
            while(!q.empty()){
                int sz = q.size();
                bool flag = 0;
                while(sz--){
                    int cur = q.front();
                    q.pop();
                    if(visited[cur]) continue;
                    visited[cur] = 1;
                    
                    if(set.find(cur) == set.end() && cur != x){
                        have[x] += 1;
                    }
                    else if(set.find(cur) != set.end() && cur != x){
                        deleted.insert(x);
                        deleted.insert(cur);
                        have[x] = 0;
                        have[cur] = 0;
                        flag = 1;
                        break;
                    }
                    if(flag) break;
                    for(auto y : next[cur]){
                        if(visited[y]) continue;
                        q.push(y);
                    }
                }
            }
        }

        

        int maxVal = -1;
        int res = INT_MAX;
        for(auto x : initial){
            if(deleted.find(x) != deleted.end()) continue;
            if(have[x] > maxVal){
                maxVal = have[x];
                res = x;
            }
            else if(have[x] == maxVal){
                res = min(res,x);
            }
        }

        if(res == INT_MAX) {
            for(auto x : initial){
                res = min(x, res);
            }
        }

        return res;
    }
};

// Union_Find TC:O(n^2*lgn) SC:O(n+k)
class Solution {
    vector<int> parent;
    int find(int x){
        if(x != parent[x]){
            parent[x] = find(parent[x]);
        }

        return parent[x];
    }
    void union_(int x, int y){
        x = find(x);
        y = find(y);
        if(x > y){
            parent[x] = y;
        }
        else parent[y] = x;
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        parent.resize(n);
        for(int i = 0 ; i < n; i++){
            parent[i] = i;
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i != j && graph[i][j] == 1 && find(i) != find(j)){
                    union_(i, j);
                }
            }
        }

        unordered_map<int,int> countAll; // root idx -> all finally infected node
        for(int i = 0; i < n; i++){
            countAll[find(i)] += 1;
        }

        unordered_map<int, vector<int>> countInitial; // root idx -> initially infected node
        for(int j : initial){
            countInitial[find(j)].push_back(j);
        }

        int maxSize = 0;
        int res = INT_MAX;
        for(auto x : countInitial){
            int cur = x.first;
            if(countInitial[cur].size() == 1){
                if(maxSize < countAll[cur]){
                    maxSize = countAll[cur];
                    res = countInitial[cur][0];
                }
                else if(maxSize == countAll[x.first]){
                    res = min(res, countInitial[cur][0]);
                }
            }
        }
        if(res == INT_MAX){
            for(auto x : initial){
                res = min(res, x);
            }
        }

        return res;

    }
};


/*
有1的位置代表 nodei 與 j互相連通
[1,1,0]
[1,1,0]
[0,0,1]
代表0 -> 1
1 -> 0 ,1
2-> 0
你可以cure任意一點 問說cure哪一點initial點能讓惡意軟體的傳播最小化 如果有很多這種點
回傳index最小的
initial數組 裝已經被infected的node
所以我必須知道每一點包含多少的child以及他的child還有多少child 選最多child的那點
難點在於如何判斷移除哪點 如果兩點數量相同且互相影響
1. 如果聯通分量裡面包含其他initial 刪誰都不對 排除這些可能
2. 如果大家都互相包含 那就選initial 最小的點
*/
